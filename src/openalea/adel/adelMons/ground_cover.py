import Image
import math


class ground_cover:
    """compute groud cover from bmp files generated by pov-ray - takes into account the camera position and fov"""

    def __init__(self):
        pass

    def __call__(self, img, cam_pos, fov, dGR, dGB):
        # OK si photo/simulation perpective!!

        # calcul des dimensions de la photo recadree a 80cm de large
        im = Image.open(img)
        xsize, ysize = im.size
        angle_conv = math.radians(fov)
        Larg_sol = 2 * cam_pos[0] * math.tan(angle_conv / 2.0)
        Larg80_pix = int(round(xsize * 0.8 / Larg_sol, 0))
        res = Image.new("RGB", (Larg80_pix, ysize), (255))

        # creation de l'image de sortie et comptage des pixels sol et vegetation pour le taux de couverture
        veg, sol = 0, 0
        for i in range(Larg80_pix):
            for j in range(ysize):
                test = self.tri_pix_veg(im, i + (xsize - Larg80_pix) / 2, j, dGR, dGB)
                if test == 1:
                    veg = veg + 1
                    res.putpixel((i, j), (0, 0, 0))
                else:
                    sol = sol + 1
                    res.putpixel((i, j), (255, 255, 255))

        # res.show()
        res.save(img[:-4] + "_tresh.jpg")  # sauvegarde de la photo traitee

        return [img.split("\\")[-1], veg, sol, float(veg) / float(veg + sol)], img[
            :-4
        ] + "_tresh.jpg"

    def tri_pix_veg(self, im, x, y, dGR, dGB):
        # seuillage sur bande verte (teste delta avec bleu et rouge)
        rgb = im.getpixel((x, y))
        if rgb[1] - rgb[0] > dGR and rgb[1] - rgb[2] > dGB:
            res = 1
        else:
            res = 0

        return res
